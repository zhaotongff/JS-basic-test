<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    //   基本排序
   /* function mySort() {
        var l=arguments.length;
        var tags = new Array();//使用数组作为参数存储容器
        for(var i=0;i<l;i++){
            tags.push(arguments[i]);
        }
        tags .sort(
            function (a,b) {
                return a-b;
            }
        )//请补充你的代码
        return tags;//返回已经排序的数组
    }

    var result = mySort(50,11,16,32,24,99,57,100);//传入参数个数不确定
    console.info(result);//显示结果*/

   ///////////////////////////////
    // <1 >  冒泡排序
  /*  冒泡排序对有n个元素的项目平均需要O(n^2)次比较次数，它可以原地排序，并且是能简单实现的几种排序算法之一
    比较相邻的元素。如果第一个比第二个大，就交换它们两个；

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

针对所有的元素重复以上的步骤，除了最后一个；

重复步骤1~3，直到排序完成。*/


   /* var arr=[5, 100, 6, 3, -12]
    bubbleSort(arr)
      function bubbleSort(arr){
          for(var i=0;i<arr.length;i++){
              for(var j=0;j<arr.length-1-i;j++){
                  if(arr[j]>arr[j+1]){
                      var temp=arr[j]
                      arr[j]=arr[j+1]
                      arr[j+1]=temp
                  }
              }
          }
          alert(arr)
      }*/


    ////////////////////////////////////////////

    /*<2>快速排序*/
    /*快速排序

    算法原理:通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
算法描述与实现具体算法描述如下：

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为“基准”（pivot）；

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。

在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。*/

    /*function quickSort(arr) {
        if (arr.length == 0) return [];

        var left = [];
        var right = [];
        var pivot = arr[0];
        for (var i = arr.length; --i;) {
            if (arr[i] < pivot)
                left.push(arr[i]);
            else
                right.push(arr[i]);
        }

        return quickSort(left).concat(pivot, quickSort(right));
    }
    var arr=[6,3,2,4,6,1,8,9,7]
    alert(quickSort(arr))*/

    ///////////////////////////////////////////////////

    ////////////////////////////////////////////////////////
    /* <3>  选择排序*/
    /* 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，

 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
     选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，

 它们当中至少有一个将被移到其最终位置上，因此对nn个元素的表进行排序总共进行至多n−1n−1次交换。在所有的完全依靠交换去移动元素的排

     序方法中，选择排序属于非常好的一种。 但原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；*/
/*
    var arr=[5,3,8,6,4]
    alert(selectSort(arr))
function selectSort(arr){
if(arr==null||arr.length==0){
    return[];
}
var minIndex=0,temp;
for(var i=0;i<arr.length;i++ ){
    minIndex=i;
    for(var j=i+1;j<arr.length;j++){
        if(arr[j]<arr[minIndex]){
            minIndex=j;
        }
    }
    if(minIndex!=i) {
        temp=arr[i];
        arr[i]=arr[minIndex];
        arr[minIndex]=temp
    }
}
return arr
}*/


    ///////////////////////////////////////

    /*4  插入排序*/
    /*插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前s扫描，

找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)O(1)的额外空间的排序），因而在从后向前的扫描过程中，

需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间*/

   /* var arr=[3,2,5,1,  8,4,6]
    alert(insertSort(arr))
function insertSort(arr){
    for(var i=1;i<arr.length;i++){
        var temp=arr[i];
        for(var j=i-1;j>=0;j--){
            if(arr[j]>temp){
                arr[j+1]=arr[j];
                arr[j]=temp

            }
            console.log(arr)
        }
      //  return arr
    }

}
*/
/*5 堆排序*/


    /* 排序思路：（降序）
     * 将堆根保存于尾部，并对剩余序列调用调整函数，调整完成后，再将最大跟保存于尾部-1（-1，-2，…，-i），
     * 再对剩余序列进行调整，反复进行该过程，直至排序完成。
     */
    function buildHead(arr) {

        //建堆
        var len = arr.length, temp;
        for (var i = Math.floor(len / 2) - 1; i >= 0; i--) {
            AdjustHeap(arr, i, len);

        }
     
        for (var j = len - 1; j >= 1; j--) {
            temp = arr[0];
            arr[0] = arr[j];
            arr[j] = temp;
            AdjustHeap(arr, 0, --len);
        }
        return arr;
    }
    function AdjustHeap(arr, pos, len) {
        var l = 2 * pos + 1, r = 2 * pos + 2, largest = pos, temp;
        if (l < len && arr[l] > arr[largest]) {
            largest = l;
        }
        if (r < len && arr[r] > arr[largest]) {
            largest = r;
        }
        if (largest !=pos) {
            temp = arr[pos];
            arr[pos] = arr[largest];
            arr[largest] = temp;
            AdjustHeap(arr, largest, len);
        }
        
    }
    var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];
    console.log(buildHead(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96];
   /* /!* 将最大的元素调整到堆顶*!/
    function AdjustHeap(arr, pos, len){
        var swap = arr[pos];      //保存当前节点
        var child = pos * 2 + 1;  //定位到当前节点的左边的子节点
        while(child < len){       //递归遍历所有的子节点
                                  //判断当前节点是否有右节点，若右节点较大，就采用右节点和当前节点进行比较
            if(child + 1 < len && arr[child] < arr[child + 1]){
                child += 1;
            }
            //比较当前节点和最大的子节点，小于就交换，交换后将当前节点定位到子节点上
            if(arr[pos] < arr[child]){
                arr[pos] = arr[child];
                pos = child;
                child = pos * 2 + 1;
            }
            else{
                break;
            }
            arr[pos] = swap;

        }

    }

    /!* 构建堆：
     * 满足：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子结点的关键字。
     * 实现：从最后一个拥有子节点的节点开始，将该节点和其他节点进行比较，将最大的数交换给该节点，
     *      交换后再依次向前节点进行相同的交换处理，直到构建出大顶堆。
     *!/
    function BuildHeap(arr){
        for(var i=Math.floor(arr.length/2); i>=0; i--){  //构建打顶堆
            AdjustHeap(arr, i, arr.length);
        }
        console.log(arr)
    }


    var arr=[49,38,65,97,76,13,27,49]
    console.log(BuildHeap(arr))*/
    /*6  希尔排序*
希尔排序的核心理念与插入排序不同，它会首先比较距离较远的元素，而非相邻元素。
通过定义一个间隔序列来表示在排序过程中进行比较的元素之间有多远的间隔。
以5,2,1为间隔，，把整个数组按5个一组，5个一组把数组拆分，数组之间相应位置数据对比，小的往前排

  */

   /*
function shellSort(arr){
        var gap=Math.floor(arr.length/2);
        while(gap>=2){
            for(var i=gap;i<arr.length;i++){
                var temp=arr[i];
                for(var j=i-gap;j>=0;j=j-gap){
                    if(arr[j]>temp){
                        arr[j+gap]=arr[j];
                        arr[j]=temp;
                    }

                }
            }
            gap=Math.floor(gap/2);
        }
        return arr
    }

    var arr=[2,3,66,1,3,45,78]
   console.log(shellSort(arr))*/




// <7>  归并排序    /**/

/*
    var arr=[3,4,7,9,3,2,98];
    function merge(left,right){
        var result=[]
        while(left.length>0&&right.length>0){
            if(left<right){
                result.push(left.shift())
            }else{
                result.push(right.shift())

            }
        }
        return result.concat(left).concat(right)
    }
    function mergeSort(arr){
        if(arr.length==1){
            return arr;
        }
        var middle=Math.floor(arr.length/2)
        var left=arr.slice(0,middle);
        var right=arr.slice(middle);
        return  merge(mergeSort(left),mergeSort(right))
    }

    console.log(mergeSort(arr))*/
</script>
</body>
</html>